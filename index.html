<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Jeff.GitHub.com by g070817</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Jeff.GitHub.com</h1>
        <p class="view"><a href="https://github.com/g070817/jeff.github.com">View the Project on GitHub <small>g070817/jeff.github.com</small></a></p>
        <ul>
          <li><a href="https://github.com/g070817/jeff.github.com/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/g070817/jeff.github.com/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/g070817/jeff.github.com">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p>Create CV page for Jeff GAO</p>
		<ul>
			<li><h1>第一天-2016/06/13</h1></li>
			<p>Javascript是一种专为“<em>与网页交互而设计</em>”的“<em>脚本</em>”语言。有下列三个不同的部分组成：</p>
			<ul>
				<li><strong>ECMAScript</strong>, 由ECMA-262定义，提供核心语言功能（包括语法，类型，语句，关键字，保留字，操作符，对象）</li>
				<li><strong>文档对象模型（DOM：Document Object Model）</strong>，提供访问与操作网页内容的方法和接口。DOM把整个页面映射为一个多层节点结构。</li>
				<li><strong>浏览器对象模型（BOM: Browser Object Model）</strong>，提供与浏览器交互的方法和接口。通过BOM可以控制浏览器显示的页面以外的部分。
					<ol>
						<li>弹出新浏览器窗口的功能</li>
						<li>移动、缩放和关闭浏览器窗口的功能</li>
						<li>提供浏览器详细信息的navigator对象</li>
						<li>提供浏览器所加载页面的详细信息的location对象</li>
						<li>提供用户显示器分辨率详细信息的screen对象</li>
						<li>对cookies的支持</li>
						<li>自定义对象（像XMLHttpRequest和IE的ActiveXObject这样的）</li>
					</ol>
				</li>
			</ul>
			<p>Script的使用的两种方式： 直接在页面中嵌入Javascript代码 || 包含外部Javascript文件</p>
			<ul>
				<li>直接嵌入Javascript代码 - 不推荐</li>
				<li>包含外部Javascript文件 - 推荐使用</li>
				<p>关键属性: src = "外部文件 or 外部域文件（来自于在线的站点）， type = "text/javascript"</p>
				<p>放置位置：body里面，主要或全部内容之后，如果放在head里面，可能会导致页面加载延迟，显示内容之前会保持空白页面</p>
				<p>noscript标签： 使用该标签时，在浏览器不支持javascript或者Javascript被禁用时显示标签中的内容</p>
			</ul>
			<li><h1>第2天-2016/06/15</h1></li>
				<h5>----科目三考试简直就是去练级打怪，还好一次性通过，但是也浪费了整整一天</h5>
				<p>区分大小写</p>
				<p>标识符： 变量、函数、属性、函数的参数</p>
				<p>首字符：必须是字母，下划线，或者$符号 && 驼峰大小写格式：第一个字母小写，后面每个单词的首字母大写</p>
				<p>关键字和保留字: break case catch continue debugger* default delete do else finally for function if in instanceof new return switch this throw try typeof var void while with</p>
				<p><strong>基本数据类型</strong>：undefined boolean string number object function</p>
				<p>Boolean(xxx); 只有boolea false值， 空字符串“”， 数字中的0和NaN， 值为null的对象，以及undefined会返回boolean false值</p>
				<p>未初始化变量和未定义变量都会返回undefined类型，但为初始化的变量的值就是undefined，而未定义变量没有值返回</p>
				<p>如果意在保存对象的变量还没有真正保存对象，就应该明确的让该变量保存null值</p>
				<p>关于数值：1. 不要尝试将两个浮点数相加然后和预测的和进行==对比，因为浮点数不够精确（1e-17），2. 最小值（5e-324）最大值（1.79769.。。。e+308）会被记录为正负无穷，将无法参与下一次对该值的运算</p>
				<p>isNaN(x): 会尝试将X转换为一个数值，例如boolean 值会被转换为0/1。但是其它有包含数字的非数值可能会被转换为数值。</p>
				<p>Number(x): boolean 值会被转换为0/1,数字仍返回数字，null和空字符串返回为0，undefined返回NaN，只包含数字的字符串会转换为对应数字-前导零会丢弃，16进制即包含0xf的字符串转为10进制数字</p>
				<p>parseInt(): 针对字符串转为数值的函数，可以传递第二个参数为进制参数，规则： 忽略字符串前面的空格，如果第一个非空格字符不是数字或者“-”号，返回NaN;否则会读取后续连续的数字作为返回数值，后面的非数字或未连续的数字将会被丢弃;如果有“."号，则到“."号位置返回整数值</p>
				<p>parseFloat(): 将字符串转为浮点数数值得函数，也就是说可以识别第一个”.“号，没有点号将返回整数，16进制数将只返回0</p>
				<p>String类型:</p>
				<p>转义字符： \n \t \b \r \f \\ \' \ \" \xnn \unnnn  例如： \x41表示A， \u03a3标识希腊字符sigama: Σ </p>
				<p>XXX.toString(): 每个变量都有一个toString()方法，除了null和undefined没有。num.toString(进制参数) 返回给定进制格式的字符串值。 String(object)弥补了toString()添加了对null和undefined的操作，其它object仍然是调用toString()函数</p>
				<p>Object类型： var o = new Object(); 或者 var o = {}不建议省略()；每个具体的Object实例对象都具有下列方法属性和方法： Constructor函数，hasOwnProperty(propertyName),isPrototypeOf(object),propertyIsEunmerable(propertyName)检查给定的属性是否能够用for-in语句来枚举, toLocaleString(), toString(),valueOf()</p>
				<p><strong>arguments参数：</strong>与数组类似，可以使用方括号方法访问传递的每一个参数元素，使用arguments.length可以知道传递进来多少个参数</p>
		
			http://www.cmbchina.com/http://www.cmbchina.com/http://www.cmbchina.com/
				<p><strong>javascript不允许访问内存中的位置</strong>：引用类型的值是保存在内存中的对象，操作对象时实际上是操作对象的引用而不是实际的对象，也就是说引用类型的值是按引用访问的</p>
				<p><strong>动态属性：</strong>定义基本类型值和引用类型值的方式类似，即创建一个变量并为该变量赋值。但是，对引用类型的值，可以添加、改变、删除属性和方法，基本类型不能使用动态属性</p>
				<p><strong>复制变量值：</strong>对基本类型值复制等于创建新的完全相互独立但值相等的新变量; 对引用类型复制时，实际上是复制了改引用类型变量的引用值，指向与原变量相同的一个对象</p>
				<p><strong>传递参数：</strong>所有函数的参数都是按照值传递的。</p>
				<p><strong>类型检测：</strong>typeof检测是否是基本数据类型或对象 instanceof检测是某一种引用类型的对象，更具体Array, RegExp等</p>
				<p><strong>执行环境：</strong>定义了变量及函数有权访问的其它数据，决定了它们各自的行为。全局执行环境是最外围的一个执行环境，每个函数都有自己的局部执行环境；内部变量不能被外部访问；但是with语句和try-catch语句 的catch部分变向延长了作用域范围。</p>
				<p><strong>垃圾收集：</strong>标记清除/引用计数（引用计数在循环引用时会有问题，不用时应及时手工解除引用 xxx = null；），建议：及时解除不再使用的全局对象，全局对象属性，及循环引用变量的引用。
				<h5>引用类型-数组</h5>
				<P><strong>ECMAScript数组Array</strong>：存储数据的有序列表，与其它语言不同的是javascript数组的每一项都可以存储任何类型的数据，算是javascript弱类型的体现。</p>
				<p>两种创建方式 var colors = new Array(); var colors = []; var colors = new Array(20); var colors = ["red","blue","grep"]; new 可以省略，如果唯一参数是数值的时候，则创建length=该值长度的数组。 colors.isArray(); colors.join(",") === colors.join(), alert(colors.join(“/”)),输出以/为分割的数组值 </p>
				<p><strong>栈方法、队列方法、反队列方法操作数组：</strong> 栈方法-末尾添加项：colors[colors.length] = "black"， 与colors.push("black")相等，与colors.pop()相反；队列方法-colors.shift(),返回数组第一项， colors.push("red","green")尾部添加; 反式队列方法-colors.unshift("black"), colors.pop()</p>
				<p><strong>数组排序：</strong> colors.sort()-数组每一项的值先转为字符串，然后在比较；反转函数-colors.reverse(); colors.sort(compare)-function compare(){if(value1 < value2) return 1; else if(value1 > value2) return -1; else return 0}</p>
				<p><strong>数组操作方法: </strong>colors.concat("yellow",["black", "brown"]); colors.slice(1)-复制从位置1到结尾的新数组; colors.slice(1, 4)-复制一个从位置1到位置4的新数组; colors.splice(0,2)-删除从位置0开始的2项并将删除项目存到一个新的数组里; colors.splice(2, 1, "red", "green")-从位置2开始插入2项删除1项并创建一个新数组存储删除项;</p>
				<p>数组位置方法： colors.indexOf(4) 返回colors[3]; colors.lastIndexOf(4) 返回倒数第四位</p>
				<p><strong>数组迭代方法</strong>colors.every()每一项都运算，所有为true则返回true；colors.filter()，返回符合条件的项组成的数组； colors.forEach()每一项运算，无返回值；colors.map()将每一项运算结果返回为新的数组，用来创建关联数组；colors.some()任何有一项运算返回true则返回true</p>
				<h5>Date类型</h5>
				<p>在早期Java中的java.util.Date基础上构建，使用自UTC1970年1月1日午夜0时开始经过的毫秒数来保存日期。var now = new Date(); Date.parse()接收一个表示日期的字符串参数var someday = newDate(Date.parse("June 16, 2016")); === var someday = new Date("June 16, 2016"); var y2k = new Date(Date.UTC(2000,0)); var y2k = new Date(Date.UTC(2005,4,3,2,1)); 后面的方式基于本地时间设置 var y2k = new Date(2000, 0); var y2k = new Date(2005,4,3,2,1); Date.now();</p>
				<p><strong>日期格式化方法</strong>：显示星期月日年 - Date().toDateString(); 显示时分秒 - Date().toTimeString()； Date().toLocalDateString()； Date().toLocalTimeString(); toUTCStting(); toLocalString() == toString(); 其它方法还可以分别取得或设置年份，月份，某天，小时等like getMonth()</p>
				
			<li><h1>第4天-2016/06/17</h1></li>
				<h5>面向对象的程序设计</h5>	
				<p><strong>创建对象</strong>:理解对象，及创建对象的几种模式-工厂模式-构造函数模式-原型模式-及构造函数和原型组合模式等，其中组合构造函数模式和原型模式的方法最优，其中构造函数模式用于定义实例属性，而原型模式用于定义方法和需要共享的属性，最大限度地节省内存S6.2.4 -P178-P159,还可以进一步使用动态原型模式，即在需要时才对原型部分进行初始化</p>
				<p><strong>继承</strong>:ECMAScript只支持“实现继承”，不支持接口和类继承，实现集成的方式主要是依靠原型链来实现的。即修改新的函数/对象的proptype属性指向到被继承的函数/对象的实例上，而不是自己的构造函数。</p>
				<p>组合继承：借助于创建对象的思维方式，以及call()或apply()方法，可以实现组合的继承方式，即在子对象中的环境中运行父类的call()方法super.call()，实现父方法中实例属性继承，通过将新对象的原型链proptype指向父对象的构造函数实现方法继承，并且还可以通过*.proptype.functionName() = function()来扩展新的方法。ECMAScript支持面向对象编程但不使用类或接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格意义的实体</p>
			<li><h1>第5天-2016/06/19</h1></li>
				<h5>jQuery</h5>		
				<ul>
					<li><strong>1. jQuery是Javascript函数库</strong></li>
					<li><strong>2. 如何引入？</strong> 下载后本地引入开发版/压缩版 | 使用官方及第三方的CDN内容分发网络在线引用</li>
					<li><strong>3. jQuery特性：</strong>HTML元素选取，HTML元素操作，CSS事件，HTML元素事件，Javascript特效和动画，HTML DOM遍历和修改，AJAX，Utilities</li>
					<li><strong>4. 基础语法：</strong> 标准模式jQuery(selector).action() | 简单模式$(selector).action() 不能使用$的情况下可以先使用$.noConfict()取消jQuery简单模式；最常用的文档就绪函数 $(document).ready(function(){--- jQuery functions go here ---}); 例子：$(this).hide() 隐藏正在操作的当前元素 $("p").hide() 隐藏所有段落 $(".test").show(1000) 显示类名为test的段落 $("#test").hide()隐藏id为test的段落</li>
					<li><strong>5. jQuery选择器：</strong>允许对单个元素（基于名字），元素组（基于标签或同个类名），或限定范围的选择和遍历方法选择，还可以对基于属性进行选择，以及css选择器（用来改变所选元素的css样式）</li>
					<li><strong>6. jQuery事件：</strong>一般用以选择器选择的元素进行某个具体的操作或操作后的更多事件响应函数进行回调，即触发某个具体事件或者把某个事件函数绑定到某个元素上，在特定事件触发时，执行该函数</li>
					<li>----事件分析：</li>
					<li><strong>7. jQuery效果-事半功倍：</strong> 隐藏hide(speed, callback)/显示/show(speed, callback)/切换toggle()/淡入fadeIn(speed, callback)/淡出fadeOut(speed, callback)/渐变切换Fadetoggle()/透明渐变fadeTo(speed,opacity,callback)/滑动slideDown(speed, callback)/slideUp(speed, callback)/slideToggle(speed, callback)/动画$(selector).animate({params},speed, callback)其中params是成对出现的css参数,参数值还可以设置为hide/show/toggle, 调用多次按顺序执行/$(selector).stop(stopAll, goToEnd),两个可选参数，其中第二个参数goToEnd依赖第一个参数stopAll / callback:如果希望某个事件发生后继续执行语句，必须使用callback函数/ 允许一个jQuery语句中依次执行多个jQuery方法-例子$("#p1").css("color","red").slideUp(2000).slideDown(2000);</li>
				</ul>
				<li><h1>第6天-2016/06/20</h1></li>
				<ul>
				<li><strong>8. jQuery 操作：</strong> 获得内容的3个方法 text()-返回所选元素里的文本/内容, html()-返回html标签及标签里的内容/文本, val()-返回表单里的值 格式例子 $(selector).text() </li>
					<li><strong>9. jQuery 属性操作:</strong>$("p:first").addClass("intro");像制定元素添加类名 $(selector).attr(attribute) 返回元素的值 $(selector).attr(attribute,value) / $("img").attr({width:"50",height:"80"});设置元素属性和值 hasClass() / removeAttr() removeClass() var() html()</li>
					<li><strong>10. jQuery css操作：</strong>css() 设置或返回匹配元素的css样式属性 height() 设置或返回匹配元素的高度 width()返回或设置匹配元素宽度 offset()返回或设置匹配元素相对于文档的偏移量（top/left2个方向）offsetParent()返回父元素 position() 返回匹配元素的位置（相对于可见父元素）scrolLeft() scrolTop()返回滚动条左侧和上侧的移动距离</li>
					<li><strong>11. jQuery 文档操作：</strong>DOM操作，匹配元素后插入内容：$(content).prependTo(selector); $(selector).after(content) / $(selector).after(function(index)); 向匹配元素开头/结尾添加内容：$(selector).prepend(content); $(selector).append(content); $(selector).append(function(index,html)); 另外类似功能-添加内容到指定元素开头/结尾： $(content).appendTo(selector); 复制匹配元素 $(selector).clone(includeEvents); 从页面删除p元素及其子元素，保存到test中：var test = $("p").detach(); 删除子节点$("div").empty(); 匹配元素前/后插入$(content).insertAfter(selector);$(content).insertBefore(selector); 删除匹配元素 $("p").remove(); 删除指定元素中的属性 $("p").removeAttr(); 删除类名$(selector).removeClass(class); $(selector).removeClass(function(index,oldclass)); toggleClass(); 替换：$(selector).replaceWith(content); $(content).replaceAll(selector); 包裹wrap();unwrap();wrapAll();wrapinner(); </li>
					<li><strong>12. jQuery 文档遍历：</strong>向上祖先：parent(); parents(); parentsUntil();后代向下：children(); find(); 同胞：siblings()-所有同胞; next(); nextAll(); nextUntil();prev();prevAll();prevUntil();-过滤：$(selector).find(xxx)-子集中寻找; first();last();$(selector).filter(xxx)-与selector中寻找符合的; not()-与filter相反;$(selector).eq(index)-所匹配元素第index-1个;</li>
					<li><strong>12. jQuery AJAX</strong>: 不刷新浏览器的情况下从服务器加载数据 = 局部数据微操 $(selector).load(URL-必须, data, callback); 例：$("#div1").load("demo_text.txt"); $("#div2").load("demo_text.txt #p1"); $("div3").load("demo_test.txt", function(responseTxt, statusTxt, xhr){}); AJAX GET-有可能从缓存取数据: 例$.get("./demo_test.txt", function(data, status){}); AJAX POST: 携带请求参数去获取数据， 例$.post("demo_test.txt",{name: "Jeff", city: "SH"}, function(data, status){}); 默认异步请求，即先锁住浏览器，执行完ajax部分后再执行其它，此时false为同步：$("#b01").click(function(){htmlobj=$.ajax({url:"/jquery/test1.txt",async:false}); JSON操作: $.getJSON("demo_ajax_json.js",function(result){}); 加载脚本：jQuery.getScript() 序列化表单元素，返回 JSON 数据结构数据:  x=$("form").serializeArray(); </li>
				</ul>
				<li><h1>第7天-2016/06/22</h1></li>
					<h5>函数表达式</h5>
					<li><strong> 递归： </strong> 调用函数自己，不如调用arguments.callee(); callee指向正在执行的函数的指针，但是callee在严格模式下部能使用。此时更安全的方式是使用函数表达式内匿名函数的方式来更安全。</li>
					<li><strong> 闭包： </strong> 闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。 当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被释放,因为闭包需要它们.</li>
					<li>由于闭包函数可以访问外层函数中的变量，所以外层函数在执行结束后，其作用域活动对象并不会被释放（注意，外层函数执行结束后执行环境和对应的作用域链就会被销毁），而是被闭包函数的作用域链所引用，直到闭包函数被销毁后，外层函数的作用域活动对象才会被销毁。这也正是闭包要占用内存的原因。一旦确定匿名函数使用完毕后，最好设置为null，确保正常回收占用的内存</li>
					<li>最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</li>
					<li><strong>当函数返回了一个闭包（即返回一个自己内部定义的匿名函数）时，该函数的执行会销毁，但活动变量或者说作用域会保存到闭包不存在位置。适当的时机将闭包设置为null，才不会造成内存的无故占用</strong></li>
					<li><strong> This </strong> this对象是在运行时基于函数执行环境绑定的：在全局函数中，this = window， 而当函数被某个对象作为方法调用时，this指向这个对象。但是，匿名函数的执行具有全局性，通常是指向window，却也有例外。另外，当在一个对象/函数内部通过另一个对象/函数调用call()或者apply()会改变this指向到被调用的对象。</li>
					<li><strong>块级作用域</strong>创建并立即调用/使用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用，因为执行完后函数内部的所有变量被立即销毁，不占用内存</li>
				</ul>
					
					<li><h1>第8天-2016/06/23</h1></li>
					<h5>RESTful API</h5>
						<p>1.使用HTTP动词：GET POST PUT DELETE 2.无状态连接，服务器端不应保存过多上下文状态，即每个请求都是独立的；3.为每个资源设置URI；4.通过XML JSON进行数据传递；</p>
						<p>实现上述原则的架构即可称为RESTFul架构。1.互联网环境下，任何应用的架构和API可以被快速理解；	2.分布式环境下，任何请求都可以被发送到任意服务器；3.异构环境下，任何资源的访问和使用方式都统一；</p>
						<p>restful 是一种简单的设计方案。它认为网站，或者说后台服务是对资源的管理，包括创建，更新，获取和删除。实际设计的时候，需要对资源进行合理的抽象。</p>
						<p>restful 指导原则比较简单，一切皆是资源，api 就是对资源的管理 ；restful 认为一切皆是资源， API 应该是对资源的状态的转化。</p>
						<p>GET (选择)：从服务器上获取一个具体的资源或者一个资源列表。 POST （创建）： 在服务器上创建一个新的资源。PUT（更新）：以整体的方式更新服务器上的一个资源。 PATCH （更新）：只更新服务器上一个资源的一个属性。DELETE（删除）：删除服务器上的一个资源。 HEAD ： 获取一个资源的元数据，如数据的哈希值或最后的更新时间。OPTIONS：获取客户端能对资源做什么操作的信息。</p>
						<p>建议将后端服务划分成为2大类1. domain resource server (基于domain的添删改查的操作)2. services (功能类的服务)区分这2个类型的主要区别在于系统的交互被抽象成domain.如果可以被抽象出domain 例如：登录和登出可以抽象出User 对象(domain)</p>
						<p>资源（Resource）资源的表述（Representation）状态转移（State Transfer）统一接口（Uniform Interface）超文本驱动（Hypertext Driven）</p>
						<p>REST的核心原则是将你的API拆分为逻辑上的资源。这些资源通过http被操作（GET ,POST,PUT,DELETE）。http是无状态的 幂等的意味着对同一URL的多个请求应该返回同样的结果</p>
						<p>200 ok  - 成功返回状态，对应，GET,PUT,PATCH,DELETE. 201 created  - 成功创建。	304 not modified   - HTTP缓存有效。400 bad request   - 请求格式错误。401 unauthorized   - 未授权/鉴权失败。	403 forbidden   - 鉴权成功，但是该用户没有权限。404 not found - 请求的资源不存在	405 method not allowed - 该http方法不被允许。	410 gone - 这个url对应的资源现在不可用。	415 unsupported media type - 请求类型错误。422 unprocessable entity - 校验错误时用。429 too many request - 请求过多。</p>

					<h5>JSON</h5>
						<p>JSON是一种有语法定义或者有规范的轻量级数据格式，而不是语言。很多编程语言自己都有对JSON数据的解析器和序列化器。</p>
						<p>可以表现三种类型的值：简单值，对象和数组; 简单值-类似于javasript中的基本数据类型，但是不包括undefined, 并且字符串必须加双引号。 对象-类似于javascript对象字面量，但仅包括{}内的部分，切结尾没有分号，同时最重要的-属性必须加双引号，对象仍可以嵌套对象。数组-同样类似于javasript的数组定义的字面量形式，但仅有数据部分。</p>
						<p>JSON解析：JSON可以解析为javascript对象，使用对象的方法获取相应的属性值，语法结构为 var book = JSON.parse(jsonname);</p>
						<p>JSON序列化：javascript对象也可以序列化为JSON对象，语法结构为：var jsontext = JSON.stringify(javascript对象)，但是javascript对象中的原型和方法，以及undefined的属性，都会被自动忽略，输出的是不包含任何空格和缩进格式的JSON数据对象</p>
						<p>JSON.stringify(obj,filter,option),其中obj是要JSON序列化的对象，filer是一个数组或者（键值对）函数，option是格式化参数，说明缩进字符或缩进字符量长度，缩进字符或缩进字符量长度不能超过10个字符</p>
						
					
					
				</ul>
				
			</ul>
		 </section>
	</div>
	
	
    <footer>
      <p>Project maintained by <a href="https://github.com/g070817">g070817</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
